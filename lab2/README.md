### 프록시 패턴 적용
- 기존 템플릿 패턴, 전략 패턴 등을 이용해서 부가기능과 비즈니스 로직, 변하지 않는 부분과 변하는 부분을 분리해냈지만 여전히 비즈니스 로직과 관계없는 기능을 위해 원본코드를 변경해야 했다.
- 부가기능에 해당하는 로그추적기 기능을 프록시 패턴을 이용해서 원본코드의 추가,변경 없이 적용했다.

#### 프록시 패턴 적용 v1 (인터페이스가 있는 구현 클래스에 적용)
- 실제 기능이 있는 객체(실제객체)를 구현체로 만들고 같은 인터페이스를 구현하는 프록시를 구현한다.
- 프록시에서는 로그추적기 기능을 수행하고 실제객체를 호출한다. (반드시 실제 객체에 대한 참조를 갖는다.)
- 클라이언트의 요청은 프록시가 받고 프록시에서 실제객체를 호출하고, 실제객체는 다음 객체의 프록시를 호춣도록 한다.
  - 직접 프록시가 스프링 빈으로 등록되도록 설정하고 실제 객체에 대한 생성도 함께 한다.
- 위 방법은 프록시를 만들고자 하는 인터페이스마다 프록시를 생성해야 한다는 단점이 있다. 프록시에서 수행하고자 하는 기능은 같고 실제 호출하는 객체만 다르더라도 프록시 클래스를 각각 따로 정의해줘야 하기 때문이다.

#### 프록시 패턴 적용 v2 - JDK가 제공하는 동적 프록시 기술 (InvocationHandler, PROXY)
- 리플렉션을 이용해서 인터페이스마다 프록시를 위한 구현체를 구현해야 하는 문제를 해결한다.
- `InvocationHandler`는 프록시가 수행해야 하는 로직을 정의한다.
```java
Proxy.newProxyInstance(실제객체.getClass().getClassLoader(), new Class[]{인터페이스.class}, invocationHandler);
```
- 실제객체에 대한 메타정보를 이용해서 자동으로 프록시 클래스를 생성할 수 있다. 중복되는 기능의 프록시 클래스를 직접 정의하지 않아도 된다.
- v1과 v2는 인터페이스를 반드시 사용해야 한다는 단점이 있다.
